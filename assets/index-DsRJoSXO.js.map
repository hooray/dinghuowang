{"version":3,"file":"index-DsRJoSXO.js","sources":["../../node_modules/.pnpm/path-to-regexp@8.2.0/node_modules/path-to-regexp/dist/index.js","../../src/layouts/components/Topbar/Toolbar/Breadcrumb/index.vue"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TokenData = void 0;\nexports.parse = parse;\nexports.compile = compile;\nexports.match = match;\nexports.pathToRegexp = pathToRegexp;\nexports.stringify = stringify;\nconst DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value) => value;\nconst ID_START = /^[$_\\p{ID_Start}]$/u;\nconst ID_CONTINUE = /^[$\\u200c\\u200d\\p{ID_Continue}]$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\nconst SIMPLE_TOKENS = {\n    // Groups.\n    \"{\": \"{\",\n    \"}\": \"}\",\n    // Reserved.\n    \"(\": \"(\",\n    \")\": \")\",\n    \"[\": \"[\",\n    \"]\": \"]\",\n    \"+\": \"+\",\n    \"?\": \"?\",\n    \"!\": \"!\",\n};\n/**\n * Escape text for stringify to path.\n */\nfunction escapeText(str) {\n    return str.replace(/[{}()\\[\\]+?!:*]/g, \"\\\\$&\");\n}\n/**\n * Escape a regular expression string.\n */\nfunction escape(str) {\n    return str.replace(/[.+*?^${}()[\\]|/\\\\]/g, \"\\\\$&\");\n}\n/**\n * Tokenize input string.\n */\nfunction* lexer(str) {\n    const chars = [...str];\n    let i = 0;\n    function name() {\n        let value = \"\";\n        if (ID_START.test(chars[++i])) {\n            value += chars[i];\n            while (ID_CONTINUE.test(chars[++i])) {\n                value += chars[i];\n            }\n        }\n        else if (chars[i] === '\"') {\n            let pos = i;\n            while (i < chars.length) {\n                if (chars[++i] === '\"') {\n                    i++;\n                    pos = 0;\n                    break;\n                }\n                if (chars[i] === \"\\\\\") {\n                    value += chars[++i];\n                }\n                else {\n                    value += chars[i];\n                }\n            }\n            if (pos) {\n                throw new TypeError(`Unterminated quote at ${pos}: ${DEBUG_URL}`);\n            }\n        }\n        if (!value) {\n            throw new TypeError(`Missing parameter name at ${i}: ${DEBUG_URL}`);\n        }\n        return value;\n    }\n    while (i < chars.length) {\n        const value = chars[i];\n        const type = SIMPLE_TOKENS[value];\n        if (type) {\n            yield { type, index: i++, value };\n        }\n        else if (value === \"\\\\\") {\n            yield { type: \"ESCAPED\", index: i++, value: chars[i++] };\n        }\n        else if (value === \":\") {\n            const value = name();\n            yield { type: \"PARAM\", index: i, value };\n        }\n        else if (value === \"*\") {\n            const value = name();\n            yield { type: \"WILDCARD\", index: i, value };\n        }\n        else {\n            yield { type: \"CHAR\", index: i, value: chars[i++] };\n        }\n    }\n    return { type: \"END\", index: i, value: \"\" };\n}\nclass Iter {\n    constructor(tokens) {\n        this.tokens = tokens;\n    }\n    peek() {\n        if (!this._peek) {\n            const next = this.tokens.next();\n            this._peek = next.value;\n        }\n        return this._peek;\n    }\n    tryConsume(type) {\n        const token = this.peek();\n        if (token.type !== type)\n            return;\n        this._peek = undefined; // Reset after consumed.\n        return token.value;\n    }\n    consume(type) {\n        const value = this.tryConsume(type);\n        if (value !== undefined)\n            return value;\n        const { type: nextType, index } = this.peek();\n        throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`);\n    }\n    text() {\n        let result = \"\";\n        let value;\n        while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n            result += value;\n        }\n        return result;\n    }\n}\n/**\n * Tokenized path instance.\n */\nclass TokenData {\n    constructor(tokens) {\n        this.tokens = tokens;\n    }\n}\nexports.TokenData = TokenData;\n/**\n * Parse a string for the raw tokens.\n */\nfunction parse(str, options = {}) {\n    const { encodePath = NOOP_VALUE } = options;\n    const it = new Iter(lexer(str));\n    function consume(endType) {\n        const tokens = [];\n        while (true) {\n            const path = it.text();\n            if (path)\n                tokens.push({ type: \"text\", value: encodePath(path) });\n            const param = it.tryConsume(\"PARAM\");\n            if (param) {\n                tokens.push({\n                    type: \"param\",\n                    name: param,\n                });\n                continue;\n            }\n            const wildcard = it.tryConsume(\"WILDCARD\");\n            if (wildcard) {\n                tokens.push({\n                    type: \"wildcard\",\n                    name: wildcard,\n                });\n                continue;\n            }\n            const open = it.tryConsume(\"{\");\n            if (open) {\n                tokens.push({\n                    type: \"group\",\n                    tokens: consume(\"}\"),\n                });\n                continue;\n            }\n            it.consume(endType);\n            return tokens;\n        }\n    }\n    const tokens = consume(\"END\");\n    return new TokenData(tokens);\n}\n/**\n * Compile a string to a template function for the path.\n */\nfunction compile(path, options = {}) {\n    const { encode = encodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const data = path instanceof TokenData ? path : parse(path, options);\n    const fn = tokensToFunction(data.tokens, delimiter, encode);\n    return function path(data = {}) {\n        const [path, ...missing] = fn(data);\n        if (missing.length) {\n            throw new TypeError(`Missing parameters: ${missing.join(\", \")}`);\n        }\n        return path;\n    };\n}\nfunction tokensToFunction(tokens, delimiter, encode) {\n    const encoders = tokens.map((token) => tokenToFunction(token, delimiter, encode));\n    return (data) => {\n        const result = [\"\"];\n        for (const encoder of encoders) {\n            const [value, ...extras] = encoder(data);\n            result[0] += value;\n            result.push(...extras);\n        }\n        return result;\n    };\n}\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(token, delimiter, encode) {\n    if (token.type === \"text\")\n        return () => [token.value];\n    if (token.type === \"group\") {\n        const fn = tokensToFunction(token.tokens, delimiter, encode);\n        return (data) => {\n            const [value, ...missing] = fn(data);\n            if (!missing.length)\n                return [value];\n            return [\"\"];\n        };\n    }\n    const encodeValue = encode || NOOP_VALUE;\n    if (token.type === \"wildcard\" && encode !== false) {\n        return (data) => {\n            const value = data[token.name];\n            if (value == null)\n                return [\"\", token.name];\n            if (!Array.isArray(value) || value.length === 0) {\n                throw new TypeError(`Expected \"${token.name}\" to be a non-empty array`);\n            }\n            return [\n                value\n                    .map((value, index) => {\n                    if (typeof value !== \"string\") {\n                        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n                    }\n                    return encodeValue(value);\n                })\n                    .join(delimiter),\n            ];\n        };\n    }\n    return (data) => {\n        const value = data[token.name];\n        if (value == null)\n            return [\"\", token.name];\n        if (typeof value !== \"string\") {\n            throw new TypeError(`Expected \"${token.name}\" to be a string`);\n        }\n        return [encodeValue(value)];\n    };\n}\n/**\n * Transform a path into a match function.\n */\nfunction match(path, options = {}) {\n    const { decode = decodeURIComponent, delimiter = DEFAULT_DELIMITER } = options;\n    const { regexp, keys } = pathToRegexp(path, options);\n    const decoders = keys.map((key) => {\n        if (decode === false)\n            return NOOP_VALUE;\n        if (key.type === \"param\")\n            return decode;\n        return (value) => value.split(delimiter).map(decode);\n    });\n    return function match(input) {\n        const m = regexp.exec(input);\n        if (!m)\n            return false;\n        const path = m[0];\n        const params = Object.create(null);\n        for (let i = 1; i < m.length; i++) {\n            if (m[i] === undefined)\n                continue;\n            const key = keys[i - 1];\n            const decoder = decoders[i - 1];\n            params[key.name] = decoder(m[i]);\n        }\n        return { path, params };\n    };\n}\nfunction pathToRegexp(path, options = {}) {\n    const { delimiter = DEFAULT_DELIMITER, end = true, sensitive = false, trailing = true, } = options;\n    const keys = [];\n    const sources = [];\n    const flags = sensitive ? \"\" : \"i\";\n    const paths = Array.isArray(path) ? path : [path];\n    const items = paths.map((path) => path instanceof TokenData ? path : parse(path, options));\n    for (const { tokens } of items) {\n        for (const seq of flatten(tokens, 0, [])) {\n            const regexp = sequenceToRegExp(seq, delimiter, keys);\n            sources.push(regexp);\n        }\n    }\n    let pattern = `^(?:${sources.join(\"|\")})`;\n    if (trailing)\n        pattern += `(?:${escape(delimiter)}$)?`;\n    pattern += end ? \"$\" : `(?=${escape(delimiter)}|$)`;\n    const regexp = new RegExp(pattern, flags);\n    return { regexp, keys };\n}\n/**\n * Generate a flat list of sequence tokens from the given tokens.\n */\nfunction* flatten(tokens, index, init) {\n    if (index === tokens.length) {\n        return yield init;\n    }\n    const token = tokens[index];\n    if (token.type === \"group\") {\n        const fork = init.slice();\n        for (const seq of flatten(token.tokens, 0, fork)) {\n            yield* flatten(tokens, index + 1, seq);\n        }\n    }\n    else {\n        init.push(token);\n    }\n    yield* flatten(tokens, index + 1, init);\n}\n/**\n * Transform a flat sequence of tokens into a regular expression.\n */\nfunction sequenceToRegExp(tokens, delimiter, keys) {\n    let result = \"\";\n    let backtrack = \"\";\n    let isSafeSegmentParam = true;\n    for (let i = 0; i < tokens.length; i++) {\n        const token = tokens[i];\n        if (token.type === \"text\") {\n            result += escape(token.value);\n            backtrack += token.value;\n            isSafeSegmentParam || (isSafeSegmentParam = token.value.includes(delimiter));\n            continue;\n        }\n        if (token.type === \"param\" || token.type === \"wildcard\") {\n            if (!isSafeSegmentParam && !backtrack) {\n                throw new TypeError(`Missing text after \"${token.name}\": ${DEBUG_URL}`);\n            }\n            if (token.type === \"param\") {\n                result += `(${negate(delimiter, isSafeSegmentParam ? \"\" : backtrack)}+)`;\n            }\n            else {\n                result += `([\\\\s\\\\S]+)`;\n            }\n            keys.push(token);\n            backtrack = \"\";\n            isSafeSegmentParam = false;\n            continue;\n        }\n    }\n    return result;\n}\nfunction negate(delimiter, backtrack) {\n    if (backtrack.length < 2) {\n        if (delimiter.length < 2)\n            return `[^${escape(delimiter + backtrack)}]`;\n        return `(?:(?!${escape(delimiter)})[^${escape(backtrack)}])`;\n    }\n    if (delimiter.length < 2) {\n        return `(?:(?!${escape(backtrack)})[^${escape(delimiter)}])`;\n    }\n    return `(?:(?!${escape(backtrack)}|${escape(delimiter)})[\\\\s\\\\S])`;\n}\n/**\n * Stringify token data into a path string.\n */\nfunction stringify(data) {\n    return data.tokens\n        .map(function stringifyToken(token, index, tokens) {\n        if (token.type === \"text\")\n            return escapeText(token.value);\n        if (token.type === \"group\") {\n            return `{${token.tokens.map(stringifyToken).join(\"\")}}`;\n        }\n        const isSafe = isNameSafe(token.name) && isNextNameSafe(tokens[index + 1]);\n        const key = isSafe ? token.name : JSON.stringify(token.name);\n        if (token.type === \"param\")\n            return `:${key}`;\n        if (token.type === \"wildcard\")\n            return `*${key}`;\n        throw new TypeError(`Unexpected token: ${token}`);\n    })\n        .join(\"\");\n}\nfunction isNameSafe(name) {\n    const [first, ...rest] = name;\n    if (!ID_START.test(first))\n        return false;\n    return rest.every((char) => ID_CONTINUE.test(char));\n}\nfunction isNextNameSafe(token) {\n    if ((token === null || token === void 0 ? void 0 : token.type) !== \"text\")\n        return true;\n    return !ID_CONTINUE.test(token.value[0]);\n}\n//# sourceMappingURL=index.js.map","<script setup lang=\"ts\">\nimport useMenuStore from '@/store/modules/menu'\nimport useSettingsStore from '@/store/modules/settings'\nimport { compile } from 'path-to-regexp'\nimport Breadcrumb from '../../../Breadcrumb/index.vue'\nimport BreadcrumbItem from '../../../Breadcrumb/item.vue'\n\ndefineOptions({\n  name: 'Breadcrumb',\n})\n\nconst route = useRoute()\n\nconst settingsStore = useSettingsStore()\nconst menuStore = useMenuStore()\n\nconst { generateI18nTitle } = useMenu()\n\nconst breadcrumbList = ref<{\n  path: string\n  title?: string | (() => string)\n}[]>([])\nwatch(() => route.fullPath, (fullPath) => {\n  if (route.name === 'reload') {\n    return\n  }\n  const list = []\n  // 是否展示主页\n  if (settingsStore.settings.home.enable) {\n    list.push({\n      path: settingsStore.settings.home.fullPath,\n      title: settingsStore.settings.home.title,\n    })\n  }\n  // 是否展示主导航\n  if (fullPath !== settingsStore.settings.home.fullPath && settingsStore.settings.breadcrumb.enableMainMenu && !['single'].includes(settingsStore.settings.menu.mode)) {\n    const index = menuStore.allMenus.findIndex(item => item.children.some(r => fullPath.indexOf(`${r.path}/`) === 0 || fullPath === r.path))\n    menuStore.allMenus[index]?.meta && list.push({\n      path: '',\n      title: menuStore.allMenus[index].meta?.title,\n    })\n  }\n  route.matched.forEach((item) => {\n    if (item.meta?.breadcrumb !== false) {\n      list.push({\n        path: item.path,\n        title: item.meta?.title,\n      })\n    }\n  })\n  const findItem = settingsStore.customTitleList.find(item => item.fullPath === fullPath)\n  if (findItem) {\n    breadcrumbList.value[breadcrumbList.value.length - 1].title = findItem.title\n  }\n  breadcrumbList.value = list\n}, {\n  immediate: true,\n})\n\nfunction pathCompile(path: string) {\n  const toPath = compile(path)\n  return toPath(route.params)\n}\n</script>\n\n<template>\n  <Breadcrumb\n    v-if=\"settingsStore.mode === 'pc' && settingsStore.settings.app.routeBaseOn !== 'filesystem'\" class=\"breadcrumb whitespace-nowrap px-2\" :class=\"{\n      [`breadcrumb-${settingsStore.settings.breadcrumb.style}`]: settingsStore.settings.breadcrumb.style !== '',\n    }\"\n  >\n    <TransitionGroup name=\"breadcrumb\">\n      <BreadcrumbItem v-for=\"(item, index) in breadcrumbList\" :key=\"`${index}_${item.path}_${item.title}`\" :to=\"index < breadcrumbList.length - 1 && item.path !== '' ? pathCompile(item.path) : ''\">\n        {{ generateI18nTitle(item.title) }}\n      </BreadcrumbItem>\n    </TransitionGroup>\n  </Breadcrumb>\n</template>\n\n<style scoped>\n.breadcrumb {\n  &.breadcrumb-modern {\n    :deep(.breadcrumb-item) {\n      .text {\n        --uno: bg-muted;\n\n        padding: 6px 16px;\n        clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 50%, calc(100% - 8px) 100%, 0 100%, 8px 50%);\n\n        [dir=\"rtl\"] & {\n          clip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 50%, 100% 100%, 8px 100%, 0 50%);\n        }\n\n        &.is-link:hover {\n          --uno: bg-muted;\n        }\n      }\n\n      &:first-child .text {\n        padding-inline-start: 12px;\n        border-radius: 6px 0 0 6px;\n        clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 50%, calc(100% - 8px) 100%, 0 100%);\n\n        [dir=\"rtl\"] & {\n          border-radius: 0 6px 6px 0;\n          clip-path: polygon(8px 0, 100% 0, 100% 100%, 8px 100%, 0 50%);\n        }\n      }\n\n      &:last-child:not(:first-child) .text {\n        --uno: bg-muted;\n\n        padding-inline-end: 12px;\n        border-radius: 0 6px 6px 0;\n        clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%, 8px 50%);\n\n        [dir=\"rtl\"] & {\n          border-radius: 6px 0 0 6px;\n          clip-path: polygon(0 0, 100% 0, calc(100% - 8px) 50%, 100% 100%, 0 100%);\n        }\n      }\n\n      .separator {\n        display: none;\n      }\n    }\n  }\n}\n\n/* 面包屑动画 */\n.breadcrumb-enter-active {\n  transition: transform 0.3s, opacity 0.3s;\n}\n\n.breadcrumb-enter-from {\n  opacity: 0;\n  transform: translateX(30px) skewX(-50deg);\n}\n</style>\n"],"names":["dist","parse","compile","match","pathToRegexp","stringify","DEFAULT_DELIMITER","NOOP_VALUE","value","ID_START","ID_CONTINUE","DEBUG_URL","SIMPLE_TOKENS","escapeText","str","escape","lexer","chars","i","name","pos","type","Iter","tokens","next","token","nextType","index","result","TokenData","options","encodePath","it","consume","endType","path","param","wildcard","encode","delimiter","data","fn","tokensToFunction","missing","encoders","tokenToFunction","encoder","extras","encodeValue","decode","regexp","keys","decoders","key","input","m","params","decoder","end","sensitive","trailing","sources","flags","items","seq","flatten","sequenceToRegExp","pattern","init","fork","backtrack","isSafeSegmentParam","negate","stringifyToken","isNameSafe","isNextNameSafe","first","rest","char","route","useRoute","settingsStore","useSettingsStore","menuStore","useMenuStore","generateI18nTitle","useMenu","breadcrumbList","ref","watch","fullPath","list","item","r","_a","_b","findItem","pathCompile"],"mappings":"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","x_google_ignoreList":[0]}